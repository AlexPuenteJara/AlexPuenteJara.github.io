---
title: "DP-DÍGITOS"
output: html_document
date: "2023-12-01"
---

## DP de dígitos

Es una técnica que nos permite resolver preguntas del tipo: ¿cuántos enteros positivos hay en el rango $[L,R]$ tal que cumplen alguna propiedad, o cuántas veces aparece esa propiedad entre todos los dígitos combinados en el rango? Dicha propiedad estará relacionada de alguna manera con los dígitos de dichos números.

Normalmente estaremos usando una función $f(n)$ que nos dirá la respuesta para la propiedad, considerando todos los enteros positivos que no excedan $n$. Entonces, para saber el número de números en $[L,R]$ que cumplen, simplemente vamos a calcular $f(R)-f(L-1)$.

Para calcular $f(n)$ vamos a auxiliarnos de otra función $dp(pos,canUseAll,...)$. En esta función vamos a ir construyendo los números que cumplen con la propiedad deseada, dígito a dígito, comenzando desde el más significativo. De forma más específica, sea $n=\overline{n_1 n_2 ... n_l}$ representado dígito a dígito, y supongamos que estamos construyendo un número $x=\overline{d_1 d_2 ... d_l}$ también con $l$ dígitos, donde el orden de colocar los dígitos comienza en $d_1$ y termina en $d_l$. Los argumentos son:

$pos:$ Este argumento nos va a decir en qué posición del número estamos actualmente, de izquierda a derecha. Es decir, estamos colocando el dígito $d_{pos}$

$canUseAll:$ este es un valor booleano que nos dice si en la posición actual podemos colocar cualquier dígito entre $0$ y $9$, o solo entre $0$ y el dígito en la posición actual de $n$. Por ejemplo, supongamos que $n=527$ y estamos en $pos=0$, entonces solo podemos colocar dígitos entre el $0$ y el $5$.  

$Propiedades:$ Puede ser la suma de dígitos al momento,
el conteo de algún dígito, etc, dependiendo de la propiedad deseada.

Entonces $dp(pos,...)$ nos dirá la respuesta para la propiedad 
deseada, considerando números mayores a $n$ y que se comenzaron
a construir desde la posición $pos$, tomando el cuenta los argumentos adicionales.

Las transiciones tienen esta forma muy general:



\begin{equation*}

limit = 
\begin{cases}
 9  & si  & canUseAll== true\\
n_{pos} & si & canUseAll==false
\end{cases}
\end{equation*}

\begin{equation*}
dp(pos,canUseAll,...)= \sum_{d=0}^{limit}dp(pos+1,canUseAll \hspace{3mm} || \hspace{3mm} d<limit, ...)
\end{equation*}

Para mandar a llamar a la $DP$ usamos $f(n)=dp(0,false,...)$, y los casos base dependerán del problema, pero siempre se dan cuando ya construimos todo el número $x$, es decir, cuando $pos=l$.

La magia de este tipo de programación dinámica radica en 
que no necesitamos guardar cada secuencia de dígitos que vamos construyendo, solo cierta información referente a ellas en los argumentos adicionales.

Y además notemos que los números construidos pueden contener ceros a la izquierda. Esto puede o no ocasionar algunas consideraciones adicionales, dependiendo del problema.

## [PROBLEMA: SUMA DE DÍGITOS](https://www.spoj.com/problems/PR003004/)

Dados $L$ y $R$, hallar la suma de dígitos de todos los números entre $L$ y $R$.Ejemplo: si 
 $L=34$ y $R=37$, la respuesta debe ser $3+4+3+5+3+6+3+7=7+8+9+10=34$.

Sea $f(n)$ la suma de dígitos de todos los números positivos hasta $n$. Entonces, $dp(pos,canUseAll,sum)$ nos va a decir la suma deseada, solo considerando números construidos desde la posisión $pos$,donde $sum$ guarda la suma de la secuencia de dígitos actual.

Entonces:

\begin{equation*}
dp(pos,canUseAll,sum)= \sum_{d=0}^{limit}dp(pos+1,canUseAll \hspace{3mm}  || \hspace{3mm} d<limit, sum+d)
\end{equation*}
La mandamos llamar como: $f(n)=dp(0,false,0)$

Y el caso base es: $dp(l,canUseAll,sum)=sum$

<br>

$Ejemplo:$
Sea $n=48654=\overline{n_1 n_2 ... n_{l}}$  y $l=5$

\begin{equation*}

limit = 
\begin{cases}
 9  & si  & canUseAll== true\\
n_{pos} & si & canUseAll==false
\end{cases}
\end{equation*}

\begin{equation*}
dp(0,false,0)= \sum_{d=0}^{4}dp(1,false \hspace{3mm}  || \hspace{3mm} d<4, sum+d)
\end{equation*}

Y el caso base es: $dp(5,canUseAll,sum)=sum$



<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample1" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i> 
<p class="title"><b>CÓDIGO (por Alex Puente)</b></p>
</div>
<div id="codeExample1" class="collapse">

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll mem[17][2][150];

ll dp(int pos, bool canUseAll, int sum, const vector<int> & digits_n){
	if(pos == digits_n.size()){
		return sum;
	}
	ll &ans = mem[pos][canUseAll][sum];
	if(ans != -1) return ans;
	ans = 0;
	int limit = canUseAll ? 9 : digits_n[pos];
	for(int d = 0; d <= limit; ++d){
		ans += dp(pos + 1, canUseAll || d < limit, sum + d, digits_n);
	}
	return ans;
}

ll f(ll n){
	if(n <= 0) return 0;
	vector<int> digits_n;
	while(n > 0){
		digits_n.push_back(n % 10);
		n /= 10;
	}
	reverse(digits_n.begin(), digits_n.end());
	memset(mem, -1, sizeof(mem));
	return dp(0, false, 0, digits_n);
}

int main(){
	ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int t;
	cin >> t;
	while(t--){
		ll a, b;
		cin >> a >> b;
		ll ans = f(b) - f(a-1);
		cout << ans << "\n";
	}
	return 0;
}
```
</div>

## [ICPC-2013-C - Counting ones](https://matcomgrader.com/problem/9306/counting-ones/)
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeExample2" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i> 
<p class="title"><b>CÓDIGO (por Alex Puente)</b></p>
</div>
<div id="codeExample2" class="collapse">

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll mem[68][2][250];

ll dp(int pos, bool canUseAll, int sum, const vector<int> & digits_n){
	if(pos == digits_n.size()){
		return sum;
	}
	ll & ans = mem[pos][canUseAll][sum];
	if(ans != -1) return ans;
	ans = 0;
	int limit = canUseAll ? 1 : digits_n[pos];
	for(int d = 0; d <= limit; ++d){
		ans += dp(pos + 1, canUseAll || d < limit, sum + d, digits_n);
	}
	return ans;
}

ll f(ll n){
	if(n <= 0) return 0;
	vector<int> digits_n;
	while(n > 0){
		digits_n.push_back(n % 2);
		n /= 2;
	}
	reverse(digits_n.begin(), digits_n.end());
	memset(mem, -1, sizeof(mem));
	return dp(0, false, 0, digits_n);
}

int main(){
	ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	ll a, b;
	while(cin >> a >> b){		
	
		ll ans = f(b) - f(a-1);
		cout << ans << "\n";
	}
	return 0;
}
```
</div>
## [Counting Numbers](https://cses.fi/problemset/task/2220)
## [S - Digit Sum](https://atcoder.jp/contests/dp/tasks/dp_s)
## [D. Nastya and Scoreboard](https://codeforces.com/contest/1341/problem/D)
## [C. Classy Numbers](https://codeforces.com/contest/1036/problem/C)


